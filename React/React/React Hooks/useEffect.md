**`useEffect`** — это хук в React, который позволяет выполнять побочные эффекты в функциональных компонентах. В классовых компонентах для этих целей использовались методы жизненного цикла (`componentDidMount`, `componentDidUpdate`, `componentWillUnmount`), а в функциональных компонентах для этого предназначен хук `useEffect`.

![image.png](React/React/React%20Hooks/useEffect_img/image.png)

### Основные функции `useEffect`:

1. **Выполнение побочных эффектов**:
    - Под побочными эффектами в React понимаются операции, которые происходят вне процесса рендеринга, такие как: запросы к API, настройка подписок, изменение DOM вручную, логирование, таймеры и так далее.
2. **Контроль за выполнением эффектов**:
    - `useEffect` позволяет контролировать, когда и как часто будет выполняться код, переданный в этот хук. В зависимости от второго аргумента (зависимостей), можно настроить выполнение эффекта:
        - Каждый раз, когда компонент рендерится (без зависимостей).
        - Один раз при первом рендере (пустой массив зависимостей).
        - Каждый раз, когда изменяется значение одной из зависимостей (массив зависимостей).

```jsx
useEffect(() => {
  // код
},[kus]);
```

### Cleaning up an effect

Часто эффекты создают ресурсы, которые необходимо очистить, прежде чем компонент покинет экран, например подписку или идентификатор таймера. Для этого функция, передаваемая в `useEffect`, может возвращать функцию очистки. Например, чтобы создать подписку:

```jsx
useEffect(() => {
  const subscription = props.source.subscribe();
  return () => {
    // Clean up the subscription
    subscription.unsubscribe();
  };
});
```

Функция очистки запускается до удаления компонента из пользовательского интерфейса, чтобы предотвратить утечки памяти. Кроме того, если компонент визуализируется несколько раз (как это обычно бывает), предыдущий эффект очищается перед выполнением следующего эффекта.

> Функция очистки вызывается перед каждым размонтированием компонента.
> 

### Рендер useEffect

- При монтировании (componentDidMount): При первом рендере компонента. Если массив зависимостей пуст или отсутствует вообще, эффект useEffect вызывается после каждого рендера компонента.
- При обновлении (componentDidUpdate): Если в массиве зависимостей указаны какие-то значения, useEffect будет вызываться только при изменении этих значений.
- При размонтировании (componentWillUnmount): При удалении компонента из DOM. Если вернуть функцию из useEffect, React выполнит эту функцию при размонтировании компонента.

### Отличия useEffect и useLayoutEffect

1. **useEffect**: Этот хук срабатывает после того, как браузер отрисовал контент на экране, т.е. он вызывается после того, как DOM обновлен. `useEffect` является асинхронным и не блокирует браузер при рендеринге.
2. **useLayoutEffect**: В отличие от `useEffect`, этот хук срабатывает синхронно после всех изменений в DOM, но перед тем, как контент на экране будет обновлен. Из-за этого `useLayoutEffect` блокирует браузер на короткое время и может вызывать проблемы с производительностью, если содержит длительные операции.

> useEffect работает немного иначе, чем componentDidMount в классовых компонентах. componentDidMount - эффекты блокируют браузер. Т.е если у нас есть исскуственная задержка на 3 сек, то браузер будет заблокирован на 3 сек, а затем отрисует уже конечный результат. Т.е. componentDidMount отрисовывает уже итоговый результат всегда, без промежуточного. Но useEffect - наоборот, не блокирует браузер при выполнении эффектов. Т.е для начала у нас отрисовывается компонент, а затем срабатывает useEffect.
> 

> Но если мы хотим отобразить какую-то информацию до отрисовки страницы, то можно использовать useLayoutEffect, поведение которого полностью совпадает с поведением componentDidMount.
> 

![image.png](React/React/React%20Hooks/useEffect_img/image%201.png)

> В useEffect можно создавать функции. Если нам требуется создание функции после рендера компонента.
> 

![image.png](React/React/React%20Hooks/useEffect_img/image%202.png)