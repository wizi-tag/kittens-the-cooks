### Как в методе render отрисовать массив элементов из массива значений?

Допустим, у вас есть массив значений, и вы хотите отрисовать список элементов на основе этого массива:

```jsx
const MyComponent = () => {
  render() {
    const items = [{ id: 1, name: 'Apple'}, { id: 1, name: 'Banana'}];

    return (
      <ul>
        {items.map((item) => (
          <li key={index}>{item.id}</li>
        ))}
      </ul>
    );
  }
}

export default MyComponent;
```

### Что такое `key`?

**`key`** — это специальный атрибут, который React использует для отслеживания элементов в списках. `key` помогает React определить, какие элементы были добавлены, удалены или изменены, что делает процесс рендеринга более эффективным.

### Зачем нужен `key`?

Когда React обновляет DOM на основе изменений состояния или пропсов, он сравнивает старый и новый список элементов. `key` помогает React быстро и эффективно обнаружить изменения в списке элементов, чтобы обновить только те, которые действительно изменились, а не перерендеривать весь список.

### Что передавать в `key`?

**Уникальные идентификаторы**: Если ваши данные содержат уникальные идентификаторы (например, ID элементов), используйте их в качестве `key`. Это предпочтительный способ.

**Индекс массива**: Если у вас нет уникальных идентификаторов, можно использовать индекс элемента в массиве в качестве `key`. Однако, это не рекомендуется, если порядок элементов может измениться, так как это может привести к неправильному поведению React.

### Более подробное описание работы key

Предположим, у нас есть массив объектов. Где объект имеет ключи: `id`, `name`. Мы отрисовали этот объект через map. У нас произошло монтирование, т.е. `did mount` для каждого эл-та.

Далее первый пользователь изменил своё имя, а у второго допустим изменился `key`.

![image.png](React/React/Key_img/image.png)

Реакт начнет сранивать изменения и увидит, что у объекта ‘Anton’ ничего не изменилось.

![image.png](React/React/Key_img/image%201.png)

Пользователь ‘Alexander’ изменил своё имя, а значит, что при изменении props, компонент должен перерисоваться. Вызывается метод `did update` Alexander → Maxim.

![image.png](React/React/Key_img/image%202.png)

У компонента ‘Dmitriy’ изменился только key. Не смотря на то, что props остались такими же, компонент был размонтирован (`will unmount`) и затем создан заново (`did mount`).

### Почему лучше не использовать index.

![image.png](image%203.png)

Практический пример:

Предположим, у нас есть очередной объект с пользователями. В качестве key - мы передали index массива. Затем, удалим второй эл-нт ‘Dmitriy’:

![image.png](image%204.png)

![image.png](image%205.png)

![image.png](image%206.png)

Казалось бы, что должно быть так, но react это видит иначе:

До рендора было 5 компонентов и каждому из них был присвоен key. После обновления стало 4 компонента, каждому из которых тоже присвоен key.

![image.png](image%207.png)

Далее react с помощью одинакового key соотносит компонент до рендора и после рендора.

![image.png](image%208.png)

![image.png](image%209.png)

![image.png](image%2010.png)